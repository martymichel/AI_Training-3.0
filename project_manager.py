"""
Zentrales Projekt-Management System f√ºr AI Vision Tools
Enhanced Version mit Live Detection Settings und Status-Synchronisation
"""

import os
import json
import yaml
import shutil
import logging
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple, TYPE_CHECKING

if TYPE_CHECKING:
    from project_manager import ProjectManager  # Nur f√ºr Type Checker

from dataclasses import dataclass, asdict
from enum import Enum

# PyQt6 Imports f√ºr Dialog-System
from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QListWidget,
    QListWidgetItem, QLabel, QLineEdit, QFileDialog, QMessageBox,
    QGroupBox, QTextEdit, QProgressBar, QWidget, QGridLayout, QFrame,
    QCheckBox
)
from PyQt6.QtCore import Qt, QThread, pyqtSignal, QObject
from PyQt6.QtGui import QFont

# Logging-Konfiguration
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Datei zur Speicherung zuletzt genutzter Projekte
RECENT_PROJECTS_FILE = Path.home() / ".ai_vision_recent_projects.json"


def load_recent_projects() -> List[str]:
    """L√§dt Liste k√ºrzlich genutzter Projekte."""
    try:
        if RECENT_PROJECTS_FILE.exists():
            with open(RECENT_PROJECTS_FILE, "r", encoding="utf-8") as f:
                data = json.load(f)
                if isinstance(data, list):
                    return data
    except Exception as e:
        logger.warning(f"Fehler beim Laden der Projekt-Historie: {e}")
    return []


def add_recent_project(path: str):
    """Speichert Projektpfad in der Historie, falls noch nicht vorhanden."""
    projects = load_recent_projects()
    if path not in projects:
        projects.append(path)
        try:
            with open(RECENT_PROJECTS_FILE, "w", encoding="utf-8") as f:
                json.dump(projects, f, indent=2)
        except Exception as e:
            logger.warning(f"Fehler beim Speichern der Projekt-Historie: {e}")

class ProjectCreationWorker(QThread):
    """Worker-Thread f√ºr Projekt-Erstellung mit Progress-Updates"""
    
    progress_updated = pyqtSignal(int, str)  # progress, message
    creation_finished = pyqtSignal(bool, str, str)  # success, message, project_path
    
    def __init__(self, project_name: str, project_directory: str, description: str = ""):
        super().__init__()
        self.project_name = project_name
        self.project_directory = project_directory
        self.description = description
    
    def run(self):
        """Erstellt Projekt in separatem Thread"""
        try:
            self.progress_updated.emit(10, "Validiere Projekt-Parameter...")
            
            # Validierung
            if not self.project_name or not self.project_directory:
                self.creation_finished.emit(False, "Projekt-Name und Verzeichnis sind erforderlich", "")
                return
            
            self.progress_updated.emit(20, "Erstelle Projekt-Verzeichnis...")
            
            # Projekt-Pfad zusammensetzen
            project_path = Path(self.project_directory) / self.project_name
            
            self.progress_updated.emit(30, "Initialisiere Projekt-Manager...")
            
            # Projekt-Manager erstellen (erstellt automatisch alle Verzeichnisse)
            project_manager = ProjectManager(str(project_path))
            
            self.progress_updated.emit(70, "Speichere Projekt-Beschreibung...")
            
            # Beschreibung speichern (falls vorhanden)
            if self.description:
                desc_file = project_path / "project_description.txt"
                with open(desc_file, 'w', encoding='utf-8') as f:
                    f.write(self.description)
            
            self.progress_updated.emit(90, "Finalisiere Projekt-Setup...")
            
            # Zus√§tzliche README erstellen
            readme_file = project_path / "README.md"
            with open(readme_file, 'w', encoding='utf-8') as f:
                f.write(f"""# {self.project_name}

## Projekt-Beschreibung
{self.description or 'Keine Beschreibung verf√ºgbar'}

## Erstellungsdatum
{datetime.now().strftime('%d.%m.%Y %H:%M')}

## Verzeichnis-Struktur
- `01_raw_images/` - Rohe Kamera-Aufnahmen
- `02_labeled/` - Gelabelte Bilder mit Annotations
- `03_augmented/` - Augmentierte Trainingsdaten
- `04_splitted/` - Train/Val/Test Aufteilung
- `05_models/` - Trainierte YOLO-Modelle
- `06_verification/` - Verifikations-Resultate
- `07_logs/` - System-Logs und Reports

## Workflow
1. Bilder aufnehmen (Kamera-Tool)
2. Bilder labeln (Labeling-Tool)
3. Daten augmentieren (optional)
4. Dataset splitten
5. Modell trainieren
6. Modell verifizieren
7. Live-Erkennung

Generated by AI Vision Tools
""")
            
            self.progress_updated.emit(100, "Projekt erfolgreich erstellt!")

            # Projektpfad in Historie speichern
            add_recent_project(str(project_path))

            self.creation_finished.emit(
                True,
                f"Projekt '{self.project_name}' wurde erfolgreich erstellt!",
                str(project_path),
            )
        except PermissionError as e:
            self.creation_finished.emit(False, f"Keine Berechtigung zum Erstellen des Projekts:\n{str(e)}", "")
        except FileExistsError as e:
            self.creation_finished.emit(False, f"Projekt-Verzeichnis existiert bereits:\n{str(e)}", "")
        except Exception as e:
            logger.error(f"Fehler bei Projekt-Erstellung: {e}")
            self.creation_finished.emit(False, f"Unerwarteter Fehler bei Projekt-Erstellung:\n{str(e)}", "")

class ProjectManagerDialog(QDialog):
    """Robuster Dialog f√ºr Projekt-Management (Neu/√ñffnen/L√∂schen)"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Projekt-Manager - AI Vision Tools")
        self.setModal(True)
        self.setMinimumSize(900, 700)
        self.selected_project = None
        self.creation_worker = None
        
        self.init_ui()
        self.refresh_project_list()
    
    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setSpacing(15)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Titel mit Icon
        header_layout = QHBoxLayout()
        title = QLabel("Projekt-Manager")
        title.setFont(QFont("Arial", 18, QFont.Weight.Bold))
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        header_layout.addWidget(title)
        layout.addLayout(header_layout)
        
        # Subtitle
        subtitle = QLabel("W√§hlen Sie ein bestehendes Projekt oder erstellen Sie ein neues")
        subtitle.setFont(QFont("Arial", 12))
        subtitle.setAlignment(Qt.AlignmentFlag.AlignCenter)
        subtitle.setStyleSheet("color: #666; margin-bottom: 20px;")
        layout.addWidget(subtitle)
        
        # Hauptbereich
        main_layout = QHBoxLayout()
        main_layout.setSpacing(20)
        
        # Linke Seite - Projekt-Liste
        left_group = QGroupBox("Bestehende Projekte")
        left_group.setMinimumWidth(400)
        left_layout = QVBoxLayout(left_group)
        
        # Refresh-Button
        refresh_btn = QPushButton("üîÑ Liste aktualisieren")
        refresh_btn.clicked.connect(self.refresh_project_list)
        left_layout.addWidget(refresh_btn)
        
        self.project_list = QListWidget()
        self.project_list.setMinimumHeight(300)
        self.project_list.setAlternatingRowColors(True)
        self.project_list.setStyleSheet(
            """
            QListWidget::item {
                border-bottom: 1px solid #ccc;
                padding: 5px;
            }
            QListWidget::item:selected {
                background-color: #0a4273;
            }
            QListWidget::item:alternate {
                background: #242f38;
            }
            """
        )
        self.project_list.itemDoubleClicked.connect(self.open_selected_project)
        left_layout.addWidget(self.project_list)
        
        # Info-Label f√ºr Projekt-Details
        self.project_info_label = QLabel("W√§hlen Sie ein Projekt f√ºr Details")
        self.project_info_label.setStyleSheet("""
            QLabel {
                background-color: #242f38;
                border: 1px solid #ddd;
                border-radius: 5px;
                padding: 10px;
                font-family: monospace;
            }
        """)
        self.project_info_label.setMinimumHeight(80)
        left_layout.addWidget(self.project_info_label)
        
        # Connect selection change
        self.project_list.itemSelectionChanged.connect(self.update_project_info)
        
        # Buttons f√ºr bestehende Projekte
        existing_buttons = QHBoxLayout()
        open_btn = QPushButton("üìÇ √ñffnen")
        open_btn.setStyleSheet("""
            QPushButton {
                background-color: #4CAF50;
                color: #000;
                border-radius: 5px;
                padding: 10px 20px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #45a049;
            }
        """)
        open_btn.clicked.connect(self.open_selected_project)
        
        delete_btn = QPushButton("üóëÔ∏è L√∂schen")
        delete_btn.setStyleSheet("""
            QPushButton {
                background-color: #f44336;
                color: white;
                border-radius: 5px;
                padding: 10px 20px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #d32f2f;
            }
        """)
        delete_btn.clicked.connect(self.delete_selected_project)
        
        existing_buttons.addWidget(open_btn)
        existing_buttons.addWidget(delete_btn)
        left_layout.addLayout(existing_buttons)
        
        main_layout.addWidget(left_group)
        
        # Rechte Seite - Neues Projekt
        right_group = QGroupBox("Neues Projekt erstellen")
        right_group.setMinimumWidth(400)
        right_layout = QVBoxLayout(right_group)
        
        # Projekt-Name
        right_layout.addWidget(QLabel("Projekt-Name:"))
        self.project_name_input = QLineEdit()
        self.project_name_input.setPlaceholderText("z.B. Spritzguss_Qualit√§tskontrolle_2025")
        self.project_name_input.textChanged.connect(self.validate_project_input)
        right_layout.addWidget(self.project_name_input)
        
        # Projekt-Pfad
        right_layout.addWidget(QLabel("Projekt-Verzeichnis:"))
        path_layout = QHBoxLayout()
        self.project_path_input = QLineEdit()
        # Standard-Pfad setzen
        default_path = str(Path.home() / "AI_Vision_Projects")
        self.project_path_input.setText(default_path)
        
        browse_btn = QPushButton("üìÅ Durchsuchen")
        browse_btn.clicked.connect(self.browse_project_directory)
        path_layout.addWidget(self.project_path_input)
        path_layout.addWidget(browse_btn)
        right_layout.addLayout(path_layout)
        
        # Projekt-Beschreibung (optional)
        right_layout.addWidget(QLabel("Beschreibung (optional):"))
        self.project_description = QTextEdit()
        self.project_description.setMaximumHeight(120)
        self.project_description.setPlaceholderText(
            "Kurze Beschreibung des Projekts...\n"
            "z.B. Automatische Erkennung von Graten und Lunkern in Spritzgussteilen"
        )
        right_layout.addWidget(self.project_description)
        
        # Progress Bar (initially hidden)
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        right_layout.addWidget(self.progress_bar)
        
        self.progress_label = QLabel()
        self.progress_label.setVisible(False)
        self.progress_label.setStyleSheet("color: #666; font-style: italic;")
        right_layout.addWidget(self.progress_label)
        
        # Create-Button
        self.create_btn = QPushButton("üöÄ Projekt erstellen")
        self.create_btn.setMinimumHeight(50)
        self.create_btn.setStyleSheet("""
            QPushButton {
                background-color: #2196F3;
                color: white;
                border-radius: 8px;
                padding: 15px;
                font-weight: bold;
                font-size: 14px;
            }
            QPushButton:hover {
                background-color: #1976D2;
            }
            QPushButton:disabled {
                background-color: #BDBDBD;
            }
        """)
        self.create_btn.clicked.connect(self.create_new_project)
        self.create_btn.setEnabled(False)  # Initially disabled
        right_layout.addWidget(self.create_btn)
        
        main_layout.addWidget(right_group)
        layout.addLayout(main_layout)
        
        # Bottom Buttons
        bottom_layout = QHBoxLayout()
        bottom_layout.addStretch()
        
        cancel_btn = QPushButton("‚ùå Abbrechen")
        cancel_btn.setStyleSheet("""
            QPushButton {
                background-color: #757575;
                color: white;
                border-radius: 5px;
                padding: 10px 20px;
            }
            QPushButton:hover {
                background-color: #616161;
            }
        """)
        cancel_btn.clicked.connect(self.reject)
        bottom_layout.addWidget(cancel_btn)
        
        layout.addLayout(bottom_layout)
        
        # Initial validation
        self.validate_project_input()
    
    def validate_project_input(self):
        """Validiert Projekt-Eingaben und aktiviert/deaktiviert Create-Button"""
        name = self.project_name_input.text().strip()
        path = self.project_path_input.text().strip()
        
        is_valid = bool(name and path and len(name) >= 3)
        self.create_btn.setEnabled(is_valid)
        
        if not name:
            self.create_btn.setText("üöÄ Projekt erstellen - Name erforderlich")
        elif len(name) < 3:
            self.create_btn.setText("üöÄ Projekt erstellen - Name zu kurz")
        elif not path:
            self.create_btn.setText("üöÄ Projekt erstellen - Pfad erforderlich")
        else:
            self.create_btn.setText("üöÄ Projekt erstellen")
    
    def refresh_project_list(self):
        """Aktualisiert Liste der verf√ºgbaren Projekte mit robuster Suche"""
        self.project_list.clear()
        
        # Erweiterte Suche nach project_config.json Dateien
        search_paths = [
            Path.home() / "AI_Vision_Projects",
            Path.home() / "Documents" / "AI_Vision_Projects",
            Path.cwd() / "projects",
            Path.cwd(),  # Aktuelles Verzeichnis
            Path.home() / "Desktop",  # Desktop f√ºr einfachen Zugriff
        ]

        # Pfade aus der Projekt-Historie erg√§nzen
        for recent in load_recent_projects():
            search_paths.append(Path(recent))

        # Doppelte entfernen und nur existierende Pfade verwenden
        unique_paths = []
        for p in search_paths:
            if p.exists() and p not in unique_paths:
                unique_paths.append(p)
        search_paths = unique_paths
        
        projects = []
        total_searched = 0
        
        for search_path in search_paths:
            if not search_path.exists():
                continue
                
            try:
                # Rekursive Suche bis zu 3 Ebenen tief
                for project_dir in search_path.rglob("*"):
                    total_searched += 1
                    if total_searched > 1000:  # Verhindere endlose Suche
                        break
                        
                    if not project_dir.is_dir():
                        continue
                        
                    config_file = project_dir / "project_config.json"
                    if config_file.exists():
                        try:
                            with open(config_file, 'r', encoding='utf-8') as f:
                                config = json.load(f)
                                
                            projects.append({
                                'name': config.get('project_name', project_dir.name),
                                'path': str(project_dir),
                                'created': config.get('created_date', ''),
                                'modified': config.get('last_modified', ''),
                                'classes': len(config.get('classes', {})),
                                'models': len(config.get('models', []))
                            })
                        except Exception as e:
                            logger.warning(f"Fehler beim Lesen der Projekt-Config {config_file}: {e}")
                            continue
            except Exception as e:
                logger.warning(f"Fehler beim Durchsuchen von {search_path}: {e}")
                continue
        
        # Projekte zur Liste hinzuf√ºgen (sortiert nach letzter √Ñnderung)
        for project in sorted(projects, key=lambda x: x['modified'], reverse=True):
            created_date = project['created'][:10] if project['created'] else 'Unbekannt'
            modified_date = project['modified'][:10] if project['modified'] else 'Unbekannt'
            
            item_text = (f"üìÅ {project['name']}\n"
                        f"üìç {project['path']}\n"
                        f"üìÖ Erstellt: {created_date} | Ge√§ndert: {modified_date}\n"
                        f"üè∑Ô∏è {project['classes']} Klassen | ü§ñ {project['models']} Modelle")
            
            item = QListWidgetItem(item_text)
            item.setData(Qt.ItemDataRole.UserRole, project)
            self.project_list.addItem(item)
        
        if not projects:
            no_projects_item = QListWidgetItem("‚ùå Keine Projekte gefunden\nErstellen Sie ein neues Projekt")
            no_projects_item.setData(Qt.ItemDataRole.UserRole, None)
            self.project_list.addItem(no_projects_item)
    
    def update_project_info(self):
        """Aktualisiert die Projekt-Detail-Anzeige"""
        current_item = self.project_list.currentItem()
        if not current_item:
            self.project_info_label.setText("W√§hlen Sie ein Projekt f√ºr Details")
            return
        
        project_data = current_item.data(Qt.ItemDataRole.UserRole)
        if not project_data:
            self.project_info_label.setText("Keine Projekt-Details verf√ºgbar")
            return
        
        # Zus√§tzliche Infos laden
        try:
            project_path = Path(project_data['path'])
            
            # Verzeichnis-Gr√∂√üe berechnen
            total_size = 0
            file_counts = {}
            
            for subdir in ['01_raw_images', '02_labeled', '03_augmented', '04_splitted', '05_models']:
                subdir_path = project_path / subdir
                if subdir_path.exists():
                    files = list(subdir_path.rglob("*"))
                    file_count = len([f for f in files if f.is_file()])
                    file_counts[subdir] = file_count
                    
                    for file in files:
                        if file.is_file():
                            total_size += file.stat().st_size
                else:
                    file_counts[subdir] = 0
            
            # Lesbare Gr√∂√üe
            if total_size > 1024**3:
                size_str = f"{total_size / 1024**3:.1f} GB"
            elif total_size > 1024**2:
                size_str = f"{total_size / 1024**2:.1f} MB"
            elif total_size > 1024:
                size_str = f"{total_size / 1024:.1f} KB"
            else:
                size_str = f"{total_size} Bytes"
            
            info_text = f"""Projekt: {project_data['name']}
Pfad: {project_data['path']}
Gr√∂√üe: {size_str}

Datei-√úbersicht:
‚Ä¢ Raw Images: {file_counts.get('01_raw_images', 0)} Dateien
‚Ä¢ Labeled: {file_counts.get('02_labeled', 0)} Dateien  
‚Ä¢ Augmented: {file_counts.get('03_augmented', 0)} Dateien
‚Ä¢ Split: {file_counts.get('04_splitted', 0)} Dateien
‚Ä¢ Models: {file_counts.get('05_models', 0)} Dateien

Klassen: {project_data['classes']}
Modelle: {project_data['models']}"""
            
            self.project_info_label.setText(info_text)
            
        except Exception as e:
            self.project_info_label.setText(f"Fehler beim Laden der Projekt-Details:\n{str(e)}")
    
    def browse_project_directory(self):
        """√ñffnet Dialog zur Verzeichnis-Auswahl"""
        current_path = self.project_path_input.text()
        directory = QFileDialog.getExistingDirectory(
            self, "Projekt-Verzeichnis w√§hlen", current_path
        )
        if directory:
            self.project_path_input.setText(directory)
            self.validate_project_input()
    
    def create_new_project(self):
        """Erstellt neues Projekt mit Progress-Anzeige"""
        name = self.project_name_input.text().strip()
        path = self.project_path_input.text().strip()
        description = self.project_description.toPlainText().strip()
        
        if not name or not path:
            QMessageBox.warning(self, "Eingabe-Fehler", "Projekt-Name und Verzeichnis sind erforderlich.")
            return
        
        # Pr√ºfe ob Verzeichnis bereits existiert
        project_path = Path(path) / name
        if project_path.exists():
            reply = QMessageBox.question(
                self, "Verzeichnis existiert", 
                f"Das Verzeichnis '{project_path}' existiert bereits.\n\n"
                f"M√∂chten Sie es als neues AI Vision Tools Projekt initialisieren?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
            )
            if reply == QMessageBox.StandardButton.No:
                return
        
        # UI f√ºr Progress vorbereiten
        self.create_btn.setEnabled(False)
        self.progress_bar.setVisible(True)
        self.progress_label.setVisible(True)
        self.progress_bar.setValue(0)
        
        # Worker-Thread f√ºr Projekt-Erstellung starten
        self.creation_worker = ProjectCreationWorker(name, path, description)
        self.creation_worker.progress_updated.connect(self.update_creation_progress)
        self.creation_worker.creation_finished.connect(self.creation_completed)
        self.creation_worker.start()
    
    def update_creation_progress(self, progress: int, message: str):
        """Aktualisiert Progress-Anzeige"""
        self.progress_bar.setValue(progress)
        self.progress_label.setText(message)
    
    def creation_completed(self, success: bool, message: str, project_path: str):
        """Behandelt Abschluss der Projekt-Erstellung"""
        # UI zur√ºcksetzen
        self.progress_bar.setVisible(False)
        self.progress_label.setVisible(False)
        self.create_btn.setEnabled(True)
        
        if success:
            self.selected_project = project_path
            QMessageBox.information(self, "Erfolg", message)
            self.accept()
        else:
            QMessageBox.critical(self, "Fehler", message)
        
        # Worker aufr√§umen
        if self.creation_worker:
            self.creation_worker.deleteLater()
            self.creation_worker = None
    
    def open_selected_project(self):
        """√ñffnet ausgew√§hltes Projekt"""
        current_item = self.project_list.currentItem()
        if not current_item:
            QMessageBox.warning(self, "Auswahl-Fehler", "Bitte w√§hlen Sie ein Projekt aus.")
            return
        
        project_data = current_item.data(Qt.ItemDataRole.UserRole)
        if not project_data:
            QMessageBox.warning(self, "Fehler", "Ung√ºltige Projekt-Daten.")
            return
        
        project_path = project_data['path']
        
        # Validiere dass Projekt noch existiert
        if not Path(project_path).exists():
            QMessageBox.warning(
                self, "Projekt nicht gefunden",
                f"Das Projekt-Verzeichnis wurde nicht gefunden:\n{project_path}\n\n"
                f"M√∂glicherweise wurde es verschoben oder gel√∂scht."
            )
            self.refresh_project_list()
            return

        add_recent_project(project_path)
        self.selected_project = project_path
        self.accept()
    
    def delete_selected_project(self):
        """L√∂scht ausgew√§hltes Projekt"""
        current_item = self.project_list.currentItem()
        if not current_item:
            QMessageBox.warning(self, "Auswahl-Fehler", "Bitte w√§hlen Sie ein Projekt aus.")
            return
        
        project_data = current_item.data(Qt.ItemDataRole.UserRole)
        if not project_data:
            return
        
        project_path = project_data['path']
        project_name = project_data['name']
        
        reply = QMessageBox.question(
            self, "Projekt l√∂schen", 
            f"‚ö†Ô∏è WARNUNG: Projekt unwiderruflich l√∂schen? ‚ö†Ô∏è\n\n"
            f"Projekt: {project_name}\n"
            f"Pfad: {project_path}\n\n"
            f"Dies l√∂scht ALLE Dateien in diesem Verzeichnis!\n"
            f"Diese Aktion kann NICHT r√ºckg√§ngig gemacht werden!",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            QMessageBox.StandardButton.No  # Default auf No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            try:
                shutil.rmtree(project_path)
                QMessageBox.information(self, "Erfolg", f"Projekt '{project_name}' wurde gel√∂scht.")
                self.refresh_project_list()
            except PermissionError:
                QMessageBox.critical(
                    self, "Berechtigung verweigert", 
                    f"Keine Berechtigung zum L√∂schen des Projekts.\n"
                    f"M√∂glicherweise sind Dateien in Verwendung."
                )
            except Exception as e:
                QMessageBox.critical(self, "Fehler", f"Projekt konnte nicht gel√∂scht werden:\n{str(e)}")
    
    def get_selected_project(self) -> Optional[str]:
        """Gibt den Pfad des ausgew√§hlten Projekts zur√ºck"""
        return self.selected_project
    
    def closeEvent(self, event):
        """Handle dialog close event"""
        # Worker stoppen falls noch aktiv
        if self.creation_worker and self.creation_worker.isRunning():
            self.creation_worker.quit()
            self.creation_worker.wait()
        event.accept()


# ==================== STATUS SYNCHRONISATION ====================

class DetectionStatusManager(QObject):
    """Zentraler Manager f√ºr Status-Synchronisation zwischen Tabs"""
    
    # Signals f√ºr Status-Updates
    detection_status_updated = pyqtSignal(dict)  # Vollst√§ndiger Status
    detection_active_changed = pyqtSignal(bool)  # Nur An/Aus Status
    detection_results_updated = pyqtSignal(dict)  # Erkennungs-Resultate
    
    def __init__(self):
        super().__init__()
        self.current_status = {
            'active': False,
            'motion_detection_enabled': True,
            'motion_value': 0.0,
            'is_static': False,
            'detected_objects': {},
            'total_detections': 0,
            'model_loaded': False,
            'camera_connected': False,
            'fps': 0,
            'frame_count': 0
        }
    
    def update_detection_active(self, active: bool):
        """Aktualisiert aktiven Status der Objekterkennung"""
        if self.current_status['active'] != active:
            self.current_status['active'] = active
            self.detection_active_changed.emit(active)
            self.detection_status_updated.emit(self.current_status.copy())
    
    def update_motion_detection(self, enabled: bool):
        """Aktualisiert Motion Detection Status"""
        if self.current_status['motion_detection_enabled'] != enabled:
            self.current_status['motion_detection_enabled'] = enabled
            self.detection_status_updated.emit(self.current_status.copy())
    
    def update_detection_results(self, results: dict):
        """Aktualisiert Erkennungs-Resultate"""
        self.current_status.update(results)
        self.detection_results_updated.emit(results)
        self.detection_status_updated.emit(self.current_status.copy())
    
    def get_current_status(self) -> dict:
        """Gibt aktuellen Status zur√ºck"""
        return self.current_status.copy()


# Globaler Status-Manager
detection_status_manager = DetectionStatusManager()


# ==================== WORKFLOW-STATUS WIDGET - ROBUST ====================

from PyQt6.QtWidgets import QWidget, QGridLayout, QFrame, QCheckBox
from PyQt6.QtCore import pyqtSignal
from PyQt6.QtGui import QIcon, QPalette

class WorkflowStatusWidget(QWidget):
    """Robustes Widget zur Anzeige des aktuellen Workflow-Status"""
    
    step_clicked = pyqtSignal(str)  # Signal wenn Schritt angeklickt wird
    
    def __init__(self, project_manager: 'ProjectManager', parent=None):
        super().__init__(parent)
        self.project_manager = project_manager
        self.step_widgets = {}
        
        # Error-resistant initialization
        try:
            self.init_ui()
            self.update_status()
        except Exception as e:
            logger.error(f"Fehler bei WorkflowStatusWidget Initialisierung: {e}")
            # Fallback: Einfache Fehlermeldung anzeigen
            self.show_error_state()
    
    def show_error_state(self):
        """Zeigt Fehler-Status an falls Initialisierung fehlschl√§gt"""
        layout = QVBoxLayout(self)
        error_label = QLabel("‚ö†Ô∏è Fehler beim Laden des Workflow-Status")
        error_label.setStyleSheet("color: red; font-weight: bold; padding: 20px;")
        layout.addWidget(error_label)
    
    def init_ui(self):
        layout = QGridLayout(self)
        layout.setSpacing(8)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # Workflow-Schritte mit Icons und Beschreibungen
        self.steps = {
            WorkflowStep.CAMERA: {
                'title': '1. Bilder aufnehmen',
                'icon': 'üì∑',
                'description': 'Kamera-Stream & Bilderfassung'
            },
            WorkflowStep.LABELING: {
                'title': '2. Bilder labeln',
                'icon': 'üè∑Ô∏è',
                'description': 'Bounding Boxes zeichnen'
            },
            WorkflowStep.AUGMENTATION: {
                'title': '3. Daten augmentieren',
                'icon': 'üîÑ',
                'description': 'Trainingsdaten erweitern'
            },
            WorkflowStep.SPLITTING: {
                'title': '4. Dataset splitten',
                'icon': 'üìä',
                'description': 'Train/Val/Test aufteilen'
            },
            WorkflowStep.TRAINING: {
                'title': '5. Modell trainieren',
                'icon': 'üöÄ',
                'description': 'YOLO-Training durchf√ºhren'
            },
            WorkflowStep.VERIFICATION: {
                'title': '6. Modell pr√ºfen',
                'icon': '‚úÖ',
                'description': 'Genauigkeit validieren'
            },
            WorkflowStep.LIVE_DETECTION: {
                'title': '7. Live-Erkennung',
                'icon': 'üéØ',
                'description': 'Real-time Objekterkennung'
            }
        }
        
        # Erstelle Widgets f√ºr jeden Schritt
        for i, (step, info) in enumerate(self.steps.items()):
            try:
                frame = QFrame()
                frame.setFrameStyle(QFrame.Shape.StyledPanel)
                frame.setMinimumWidth(200)
                frame.setMinimumHeight(120)
                frame.setMaximumHeight(140)
                frame.setCursor(Qt.CursorShape.PointingHandCursor)
                
                # Click-Event mit Error-Handling
                def make_click_handler(step_value):
                    return lambda event: self.handle_step_click(step_value)
                
                frame.mousePressEvent = make_click_handler(step.value)
                
                frame_layout = QVBoxLayout(frame)
                frame_layout.setContentsMargins(8, 8, 8, 8)
                frame_layout.setSpacing(4)
                
                # Icon + Titel
                title_layout = QHBoxLayout()
                title_layout.setSpacing(8)
                
                icon_label = QLabel(info['icon'])
                icon_label.setFont(QFont("Arial", 24))
                icon_label.setFixedSize(32, 32)
                
                title_label = QLabel(info['title'])
                title_label.setFont(QFont("Arial", 11, QFont.Weight.Bold))
                title_label.setStyleSheet("color: black;")
                title_label.setWordWrap(True)
                
                title_layout.addWidget(icon_label)
                title_layout.addWidget(title_label, 1)
                
                # Status-Checkbox zeigt Fertigstellung an
                status_checkbox = QCheckBox()
                status_checkbox.setEnabled(False)
                status_checkbox.setFixedSize(20, 20)
                title_layout.addWidget(status_checkbox)
                
                frame_layout.addLayout(title_layout)
                
                # Beschreibung
                desc_label = QLabel(info['description'])
                desc_label.setFont(QFont("Arial", 8))
                desc_label.setStyleSheet("color: #666;")
                desc_label.setWordWrap(True)
                frame_layout.addWidget(desc_label)
                
                # Status-Text
                status_label = QLabel("Initialisierung...")
                status_label.setFont(QFont("Arial", 8))
                status_label.setStyleSheet("color: #888;")
                frame_layout.addWidget(status_label)
                
                # Widget speichern f√ºr Updates
                self.step_widgets[step] = {
                    'frame': frame,
                    'status_checkbox': status_checkbox,
                    'status_label': status_label,
                    'title_label': title_label,
                    'desc_label': desc_label
                }
                
                # Grid-Position berechnen (3 Spalten f√ºr bessere Darstellung)
                row = i // 3
                col = i % 3
                layout.addWidget(frame, row, col)
                
            except Exception as e:
                logger.error(f"Fehler beim Erstellen von Workflow-Schritt {step}: {e}")
                continue
    
    def handle_step_click(self, step_value: str):
        """Behandelt Klick auf Workflow-Schritt mit Error-Handling"""
        try:
            self.step_clicked.emit(step_value)
        except Exception as e:
            logger.error(f"Fehler beim Behandeln des Schritt-Klicks: {e}")
    
    def update_status(self):
        """Aktualisiert den Status aller Workflow-Schritte"""
        try:
            workflow_status = self.project_manager.get_workflow_status()
            
            for step, widgets in self.step_widgets.items():
                try:
                    is_completed = workflow_status.get(step.value, False)
                    can_execute, message = self.project_manager.validate_workflow_step(step)
                    
                    frame = widgets['frame']
                    status_checkbox = widgets['status_checkbox']
                    status_label = widgets['status_label']
                    
                    if is_completed:
                        # Abgeschlossen - Gr√ºn
                        status_checkbox.setChecked(True)
                        status_label.setText("Abgeschlossen")
                        status_label.setStyleSheet("color: #4CAF50; font-weight: bold;")
                        frame.setStyleSheet("""
                            QFrame {
                                background-color: #E8F5E8;
                                border: 2px solid #4CAF50;
                                border-radius: 8px;
                            }
                            QFrame:hover {
                                background-color: #E0F2E0;
                                border-color: #45a049;
                            }
                        """)
                    elif can_execute:
                        # Bereit zur Ausf√ºhrung - Blau
                        status_checkbox.setChecked(False)
                        status_label.setText("Bereit")
                        status_label.setStyleSheet("color: #2196F3; font-weight: bold;")
                        frame.setStyleSheet("""
                            QFrame {
                                background-color: #E3F2FD;
                                border: 2px solid #2196F3;
                                border-radius: 8px;
                            }
                            QFrame:hover {
                                background-color: #BBDEFB;
                                border-color: #1976D2;
                            }
                        """)
                    else:
                        # Nicht bereit - Grau
                        status_checkbox.setChecked(False)
                        status_label.setText("Warten...")
                        status_label.setStyleSheet("color: #757575;")
                        frame.setStyleSheet("""
                            QFrame {
                                background-color: #F5F5F5;
                                border: 2px solid #BDBDBD;
                                border-radius: 8px;
                            }
                            QFrame:hover {
                                background-color: #EEEEEE;
                                border-color: #9E9E9E;
                            }
                        """)
                    
                    # Tooltip mit Validierungs-Message (gek√ºrzt f√ºr bessere Lesbarkeit)
                    tooltip_message = message if message else "Klicken zum √ñffnen"
                    if len(tooltip_message) > 100:
                        tooltip_message = tooltip_message[:97] + "..."
                    frame.setToolTip(tooltip_message)
                    
                except Exception as e:
                    logger.error(f"Fehler beim Aktualisieren von Workflow-Schritt {step}: {e}")
                    # Fallback-Status bei Fehler
                    widgets['status_checkbox'].setChecked(False)
                    widgets['status_label'].setText("Fehler")
                    widgets['frame'].setStyleSheet("""
                        QFrame {
                            background-color: #FFEBEE;
                            border: 2px solid #F44336;
                            border-radius: 8px;
                        }
                    """)
                    widgets['frame'].setToolTip(f"Fehler bei Status-Update: {str(e)}")
                    
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren des Workflow-Status: {e}")


# ==================== FEHLERBEHANDLUNG & LOGGING UTILITIES ====================

class ProjectManagerError(Exception):
    """Custom Exception f√ºr Projekt-Manager Fehler"""
    pass

def setup_project_logging(project_path: Path):
    """Richtet Projekt-spezifisches Logging ein"""
    try:
        log_dir = project_path / "07_logs"
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / f"project_{datetime.now().strftime('%Y%m%d')}.log"
        
        # File Handler f√ºr Projekt-Logs
        file_handler = logging.FileHandler(log_file, encoding='utf-8')
        file_handler.setLevel(logging.INFO)
        file_formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        file_handler.setFormatter(file_formatter)
        
        # Projekt-Logger
        project_logger = logging.getLogger(f"project_{project_path.name}")
        project_logger.addHandler(file_handler)
        project_logger.setLevel(logging.INFO)
        
        project_logger.info(f"Projekt-Logging initialisiert f√ºr: {project_path.name}")
        
        return project_logger
        
    except Exception as e:
        logger.error(f"Fehler beim Einrichten des Projekt-Loggings: {e}")
        return logger

def safe_json_load(file_path: Path, default_value=None):
    """Sicheres Laden von JSON-Dateien mit Fallback"""
    try:
        if not file_path.exists():
            return default_value
            
        with open(file_path, 'r', encoding='utf-8') as f:
            return json.load(f)
            
    except json.JSONDecodeError as e:
        logger.error(f"Ung√ºltige JSON in {file_path}: {e}")
        return default_value
    except Exception as e:
        logger.error(f"Fehler beim Laden von {file_path}: {e}")
        return default_value

def safe_json_save(file_path: Path, data: dict, create_backup: bool = True):
    """Sicheres Speichern von JSON-Dateien mit Backup"""
    try:
        # Backup erstellen falls gew√ºnscht
        if create_backup and file_path.exists():
            backup_path = file_path.with_suffix('.json.backup')
            shutil.copy2(file_path, backup_path)
        
        # Tempor√§re Datei f√ºr atomares Schreiben
        temp_path = file_path.with_suffix('.json.tmp')
        
        with open(temp_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        # Atomares Umbenennen
        temp_path.replace(file_path)
        return True
        
    except Exception as e:
        logger.error(f"Fehler beim Speichern von {file_path}: {e}")
        return False

def validate_project_structure(project_path: Path) -> Tuple[bool, List[str]]:
    """Validiert die Projekt-Verzeichnis-Struktur"""
    required_dirs = [
        "01_raw_images", "02_labeled", "03_augmented", "04_splitted",
        "05_models", "06_verification", "07_logs"
    ]
    
    missing_dirs = []
    
    try:
        for dir_name in required_dirs:
            dir_path = project_path / dir_name
            if not dir_path.exists():
                missing_dirs.append(dir_name)
        
        config_file = project_path / "project_config.json"
        if not config_file.exists():
            missing_dirs.append("project_config.json")
        
        return len(missing_dirs) == 0, missing_dirs
        
    except Exception as e:
        logger.error(f"Fehler bei Projekt-Struktur-Validierung: {e}")
        return False, [f"Validierungsfehler: {str(e)}"]

def repair_project_structure(project_path: Path) -> bool:
    """Repariert fehlende Projekt-Verzeichnisse"""
    try:
        logger.info(f"Repariere Projekt-Struktur: {project_path}")
        
        # Projekt-Manager erstellen (repariert automatisch die Struktur)
        pm = ProjectManager(str(project_path))
        
        logger.info("Projekt-Struktur erfolgreich repariert")
        return True
        
    except Exception as e:
        logger.error(f"Fehler bei Projekt-Struktur-Reparatur: {e}")
        return False


# ==================== DEBUGGING & DIAGNOSTICS ====================

def diagnose_project_issues(project_path: Path) -> Dict[str, any]:
    """Diagnostiziert h√§ufige Projekt-Probleme"""
    diagnosis = {
        'project_path': str(project_path),
        'exists': project_path.exists(),
        'readable': False,
        'writable': False,
        'structure_valid': False,
        'config_valid': False,
        'issues': [],
        'recommendations': []
    }
    
    try:
        if not project_path.exists():
            diagnosis['issues'].append("Projekt-Verzeichnis existiert nicht")
            diagnosis['recommendations'].append("Projekt-Verzeichnis erstellen oder korrekten Pfad w√§hlen")
            return diagnosis
        
        # Berechtigung pr√ºfen
        try:
            diagnosis['readable'] = os.access(project_path, os.R_OK)
            diagnosis['writable'] = os.access(project_path, os.W_OK)
        except Exception:
            pass
        
        if not diagnosis['readable']:
            diagnosis['issues'].append("Keine Leseberechtigung f√ºr Projekt-Verzeichnis")
            diagnosis['recommendations'].append("Berechtigung f√ºr Verzeichnis pr√ºfen")
        
        if not diagnosis['writable']:
            diagnosis['issues'].append("Keine Schreibberechtigung f√ºr Projekt-Verzeichnis")
            diagnosis['recommendations'].append("Schreibberechtigung f√ºr Verzeichnis gew√§hren")
        
        # Struktur validieren
        structure_valid, missing = validate_project_structure(project_path)
        diagnosis['structure_valid'] = structure_valid
        
        if not structure_valid:
            diagnosis['issues'].append(f"Fehlende Verzeichnisse: {', '.join(missing)}")
            diagnosis['recommendations'].append("Projekt-Struktur reparieren")
        
        # Config validieren
        config_file = project_path / "project_config.json"
        if config_file.exists():
            config_data = safe_json_load(config_file)
            if config_data:
                diagnosis['config_valid'] = True
                # Weitere Config-Validierung
                required_fields = ['project_name', 'created_date', 'classes']
                missing_fields = [field for field in required_fields if field not in config_data]
                if missing_fields:
                    diagnosis['issues'].append(f"Fehlende Config-Felder: {', '.join(missing_fields)}")
                    diagnosis['recommendations'].append("Projekt-Konfiguration reparieren")
            else:
                diagnosis['issues'].append("Projekt-Konfiguration ist besch√§digt")
                diagnosis['recommendations'].append("Konfiguration aus Backup wiederherstellen oder neu erstellen")
        
        # Disk-Space pr√ºfen
        try:
            statvfs = os.statvfs(project_path)
            free_space = statvfs.f_frsize * statvfs.f_bavail
            if free_space < 100 * 1024 * 1024:  # < 100 MB
                diagnosis['issues'].append("Wenig freier Speicherplatz")
                diagnosis['recommendations'].append("Speicherplatz freigeben")
        except Exception:
            pass
        
    except Exception as e:
        diagnosis['issues'].append(f"Unerwarteter Fehler bei Diagnose: {str(e)}")
        diagnosis['recommendations'].append("Projekt-Pfad und -Berechtigung pr√ºfen")
    
    return diagnosis

def create_diagnostic_report(project_path: Path) -> str:
    """Erstellt einen diagnostischen Bericht f√ºr ein Projekt"""
    diagnosis = diagnose_project_issues(project_path)
    
    report = f"""
# Projekt-Diagnose Bericht

**Projekt:** {diagnosis['project_path']}
**Zeitstempel:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Status-√úbersicht
- Verzeichnis existiert: {'‚úÖ' if diagnosis['exists'] else '‚ùå'}
- Leseberechtigung: {'‚úÖ' if diagnosis['readable'] else '‚ùå'}
- Schreibberechtigung: {'‚úÖ' if diagnosis['writable'] else '‚ùå'}
- Struktur g√ºltig: {'‚úÖ' if diagnosis['structure_valid'] else '‚ùå'}
- Konfiguration g√ºltig: {'‚úÖ' if diagnosis['config_valid'] else '‚ùå'}

## Erkannte Probleme
"""
    
    if diagnosis['issues']:
        for i, issue in enumerate(diagnosis['issues'], 1):
            report += f"{i}. ‚ùå {issue}\n"
    else:
        report += "‚úÖ Keine Probleme erkannt\n"
    
    report += "\n## Empfehlungen\n"
    
    if diagnosis['recommendations']:
        for i, rec in enumerate(diagnosis['recommendations'], 1):
            report += f"{i}. üí° {rec}\n"
    else:
        report += "‚úÖ Keine Aktionen erforderlich\n"
    
    report += f"""
## Technische Details
- Python Version: {sys.version}
- Arbeitsverzeichnis: {os.getcwd()}
- Benutzer: {os.getenv('USERNAME', 'Unbekannt')}
- System: {os.name}

---
Generiert von AI Vision Tools Project Manager
"""
    
    return report


# ==================== ENHANCED PROJECT MANAGER ====================

class WorkflowStep(Enum):
    """Workflow-Schritte mit Status-Tracking"""
    CAMERA = "01_camera"
    LABELING = "02_labeling"
    AUGMENTATION = "03_augmentation"
    SPLITTING = "04_splitting"
    TRAINING = "05_training"
    VERIFICATION = "06_verification"
    LIVE_DETECTION = "07_live_detection"

@dataclass
class ProjectConfig:
    """Projekt-Konfiguration mit allen persistenten Settings"""
    # Basis-Info
    project_name: str
    created_date: str
    last_modified: str
    
    # Klassen-Management
    classes: Dict[int, str]  # {0: "Grat", 1: "Lunker", ...}
    class_colors: Dict[int, str]  # {0: "#FF0000", 1: "#00FF00", ...}
    
    # Settings (mit Default-Werten)
    camera_settings: Dict = None
    augmentation_settings: Dict = None
    training_settings: Dict = None
    
    # Live Detection Settings (ENHANCED)
    live_detection_settings: Dict = None
    
    # Workflow-Status
    workflow_status: Dict[str, bool] = None
    
    # Model-Versionierung
    models: List[Dict] = None
    current_model: Optional[str] = None

    # Annotation Type Detection
    annotation_type: str = "unknown"  # "bbox", "polygon", "mixed", "unknown"
    has_bbox_annotations: bool = False
    has_polygon_annotations: bool = False
    
    def __post_init__(self):
        """Initialisiert None-Werte mit leeren Dicts/Listen"""
        if self.camera_settings is None:
            self.camera_settings = {}
        if self.augmentation_settings is None:
            self.augmentation_settings = {}
        if self.training_settings is None:
            self.training_settings = {}
        if self.live_detection_settings is None:
            self.live_detection_settings = ProjectConfig.get_default_live_detection_settings()
        if self.workflow_status is None:
            self.workflow_status = {step.value: False for step in WorkflowStep}
        if self.models is None:
            self.models = []
    
    @staticmethod
    def get_default_live_detection_settings() -> Dict:
        """Standard Live Detection Settings"""
        return {
            # Model und Dataset
            'model_path': '',
            'yaml_path': '',
            
            # Kamera-Einstellungen
            'camera_type': 'usb',  # 'usb' oder 'ids_peak'
            'camera_id': 0,
            'exposure_time': 75000,
            'gain': 0.0,            
            'fps': 15,
            'quality': 70,
            'flip_horizontal': False,
            'flip_vertical': False,
            
            # Connection Settings
            'connection': {
                'ip': '192.168.1.99',
                'user': 'admin',
                'password': 'Flex'
            },
            
            # Motion Detection
            'motion_detection_enabled': True,
            'motion_threshold': 110,
            'static_frame_min': 3,
            
            # Object Detection
            'detection_enabled': False,
            'iou_threshold': 0.45,
            'class_thresholds': {},
            
            # Frame Configuration
            'frame_assignments': {},
            'green_threshold': 4,
            'red_threshold': 1,
            
            # Streaming Settings
            'stream_type': 'stream1',
            'auto_overlay': True,
            'encoding_type': 'MJPEG',
            'mjpeg_quality': 75,
            'resolution': 'FULL_HD'
        }

class ProjectManager:
    """Zentraler Projekt-Manager f√ºr alle AI Vision Tools - Enhanced Version"""
    
    def __init__(self, project_root: str):
        logger.info(f"Initialisiere Enhanced Projekt-Manager f√ºr: {project_root}")
        
        try:
            self.project_root = Path(project_root).resolve()
            logger.info(f"Projekt-Root absoluter Pfad: {self.project_root}")
            
            # Projekt-Verzeichnis erstellen falls nicht vorhanden
            self._ensure_project_directory()
            
            # Config-Datei-Pfad
            self.config_file = self.project_root / "project_config.json"
            logger.info(f"Config-Datei Pfad: {self.config_file}")
            
            # Verzeichnis-Struktur definieren
            self.structure = {
                "01_raw_images": "Rohe Kamera-Aufnahmen",
                "02_labeled": "Gelabelte Bilder mit Annotations", 
                "03_augmented": "Augmentierte Trainingsdaten",
                "04_splitted": "Train/Val/Test Aufteilung",
                "05_models": "Trainierte YOLO-Modelle",
                "06_verification": "Verifikations-Resultate",
                "07_logs": "System-Logs und Reports"
            }
            
            # Verzeichnis-Struktur erstellen
            self._create_directory_structure()
            
            # Konfiguration laden oder erstellen
            self.config: ProjectConfig = self._load_or_create_config()
            
            logger.info(f"Enhanced Projekt-Manager erfolgreich initialisiert: {self.config.project_name}")
            
        except Exception as e:
            logger.error(f"Fehler bei Enhanced Projekt-Manager Initialisierung: {e}")
            raise
    
    def _ensure_project_directory(self):
        """Stellt sicher, dass das Projekt-Verzeichnis existiert"""
        try:
            self.project_root.mkdir(parents=True, exist_ok=True)
            logger.info(f"Projekt-Verzeichnis sichergestellt: {self.project_root}")
        except PermissionError as e:
            logger.error(f"Keine Berechtigung zum Erstellen des Verzeichnisses: {e}")
            raise
        except Exception as e:
            logger.error(f"Fehler beim Erstellen des Projekt-Verzeichnisses: {e}")
            raise
    
    def _create_directory_structure(self):
        """Erstellt komplette Verzeichnis-Struktur mit Fehlerbehandlung"""
        logger.info("Erstelle Verzeichnis-Struktur...")
        
        for folder_name, description in self.structure.items():
            try:
                folder_path = self.project_root / folder_name
                folder_path.mkdir(parents=True, exist_ok=True)
                logger.debug(f"Verzeichnis erstellt: {folder_path} ({description})")
            except Exception as e:
                logger.error(f"Fehler beim Erstellen von {folder_name}: {e}")
                raise
        
        # Spezielle Unterordner f√ºr Split mit Fehlerbehandlung
        try:
            split_dir = self.project_root / "04_splitted"
            for subset in ["train", "val", "test"]:
                for subdir in ["images", "labels"]:
                    subpath = split_dir / subset / subdir
                    subpath.mkdir(parents=True, exist_ok=True)
                    logger.debug(f"Split-Unterverzeichnis erstellt: {subpath}")
        except Exception as e:
            logger.error(f"Fehler beim Erstellen der Split-Unterverzeichnisse: {e}")
            raise
        
        logger.info("Verzeichnis-Struktur erfolgreich erstellt")
    
    def _load_or_create_config(self) -> ProjectConfig:
        """L√§dt bestehende Config oder erstellt neue mit robuster Fehlerbehandlung"""
        logger.info(f"Lade oder erstelle Enhanced Konfiguration: {self.config_file}")
        
        if self.config_file.exists():
            try:
                logger.info("Bestehende Konfiguration gefunden - lade...")
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                
                # Validierung der geladenen Daten
                required_fields = ['project_name', 'created_date', 'last_modified', 'classes', 'class_colors']
                for field in required_fields:
                    if field not in data:
                        logger.warning(f"Feld '{field}' fehlt in Konfiguration - setze Standard")
                        data[field] = self._get_default_value(field)
                
                # Stelle sicher, dass live_detection_settings existiert
                if 'live_detection_settings' not in data:
                    logger.info("Live Detection Settings fehlen - erstelle Standard-Konfiguration")
                    data['live_detection_settings'] = ProjectConfig.get_default_live_detection_settings()

                config = ProjectConfig(**data)
                logger.info(f"Enhanced Konfiguration erfolgreich geladen: {config.project_name}")
                return config
                
            except json.JSONDecodeError as e:
                logger.error(f"Ung√ºltige JSON-Konfiguration: {e}")
                logger.info("Erstelle neue Konfiguration...")
                return self._create_new_config()
            except Exception as e:
                logger.error(f"Fehler beim Laden der Konfiguration: {e}")
                logger.info("Erstelle neue Konfiguration...")
                return self._create_new_config()
        else:
            logger.info("Keine bestehende Konfiguration gefunden - erstelle neue...")
            return self._create_new_config()
    
    def _get_default_value(self, field: str):
        """Gibt Standard-Werte f√ºr fehlende Konfigurationsfelder zur√ºck"""
        defaults = {
            'project_name': self.project_root.name,
            'created_date': datetime.now().isoformat(),
            'last_modified': datetime.now().isoformat(),
            'classes': {},
            'class_colors': {},
            'camera_settings': {},
            'augmentation_settings': {},
            'training_settings': {},
            'live_detection_settings': ProjectConfig.get_default_live_detection_settings(),
            'workflow_status': {step.value: False for step in WorkflowStep},
            'models': [],
            'current_model': None
        }
        return defaults.get(field, {})
    
    def _create_new_config(self) -> ProjectConfig:
        """Erstellt neue Enhanced Projekt-Konfiguration"""
        logger.info("Erstelle neue Enhanced Projekt-Konfiguration...")
        
        config = ProjectConfig(
            project_name=self.project_root.name,
            created_date=datetime.now().isoformat(),
            last_modified=datetime.now().isoformat(),
            classes={},
            class_colors={},
            camera_settings={},
            augmentation_settings={},
            training_settings={},
            live_detection_settings=ProjectConfig.get_default_live_detection_settings(),
            workflow_status={step.value: False for step in WorkflowStep},
            models=[],
            current_model=None
        )
        
        # Sofort speichern
        self.save_config(config)
        return config
    
    def save_config(self, config: Optional[ProjectConfig] = None):
        """Speichert Enhanced Projekt-Konfiguration mit robuster Fehlerbehandlung"""
        if config:
            self.config = config
        
        self.config.last_modified = datetime.now().isoformat()
        
        try:
            # Backup der bestehenden Config erstellen
            if self.config_file.exists():
                backup_file = self.config_file.with_suffix('.json.backup')
                shutil.copy2(self.config_file, backup_file)
                logger.debug(f"Backup erstellt: {backup_file}")
            
            # Tempor√§re Datei f√ºr atomares Schreiben
            temp_file = self.config_file.with_suffix('.json.tmp')
            
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(asdict(self.config), f, indent=2, ensure_ascii=False)
            
            # Atomares Umbenennen (verhindert korrupte Dateien)
            temp_file.replace(self.config_file)
            
            logger.debug(f"Enhanced Konfiguration erfolgreich gespeichert: {self.config_file}")
            
        except PermissionError as e:
            logger.error(f"Keine Berechtigung zum Speichern der Konfiguration: {e}")
            raise
        except Exception as e:
            logger.error(f"Fehler beim Speichern der Konfiguration: {e}")
            raise
    
    # ==================== PFAD-GETTER MIT VALIDIERUNG ====================
    
    def get_raw_images_dir(self) -> Path:
        """Verzeichnis f√ºr rohe Kamera-Aufnahmen"""
        path = self.project_root / "01_raw_images"
        path.mkdir(exist_ok=True)  # Erstelle falls nicht vorhanden
        return path
    
    def get_labeled_dir(self) -> Path:
        """Verzeichnis f√ºr gelabelte Bilder"""
        path = self.project_root / "02_labeled"
        path.mkdir(exist_ok=True)
        return path

    def detect_annotation_type(self) -> str:
        """Detektiert den Typ der Annotationen im Projekt."""
        try:
            labeled_dir = self.get_labeled_dir()
            has_bbox = False
            has_polygon = False

            # Suche nach .txt Annotation-Dateien
            for txt_file in labeled_dir.glob("*.txt"):
                try:
                    with open(txt_file, 'r', encoding='utf-8') as f:
                        for line in f:
                            line = line.strip()
                            if not line:
                                continue

                            parts = line.split()
                            if len(parts) < 5:
                                continue

                            # Bounding Box: class_id x_center y_center width height (5 Werte)
                            if len(parts) == 5:
                                has_bbox = True
                            # Polygon: class_id x1 y1 x2 y2 x3 y3 ... (6+ Werte, gerade Anzahl)
                            elif len(parts) >= 6 and len(parts) % 2 == 0:
                                has_polygon = True

                            # Fr√ºh beenden wenn beide Typen gefunden
                            if has_bbox and has_polygon:
                                break

                    if has_bbox and has_polygon:
                        break

                except Exception as e:
                    logger.warning(f"Fehler beim Lesen von {txt_file}: {e}")
                    continue

            # Annotation-Typ bestimmen
            if has_bbox and has_polygon:
                annotation_type = "mixed"
            elif has_polygon:
                annotation_type = "polygon"
            elif has_bbox:
                annotation_type = "bbox"
            else:
                annotation_type = "unknown"

            # Konfiguration aktualisieren
            self.config.annotation_type = annotation_type
            self.config.has_bbox_annotations = has_bbox
            self.config.has_polygon_annotations = has_polygon
            self.save_config()

            logger.info(f"Annotation-Typ erkannt: {annotation_type} (bbox: {has_bbox}, polygon: {has_polygon})")
            return annotation_type

        except Exception as e:
            logger.error(f"Fehler bei Annotation-Typ-Erkennung: {e}")
            return "unknown"

    def get_recommended_model_type(self) -> str:
        """Empfiehlt Modell-Typ basierend auf Annotation-Typ."""
        annotation_type = self.detect_annotation_type()
        labeled_dir = self.get_labeled_dir()
            
        # Sammle alle Label-Dateien
        label_files = list(labeled_dir.glob("*.txt"))
        if not label_files:
            return "detection"  # Default wenn keine Labels vorhanden
        
        # Analysiere Format der ersten paar Label-Dateien
        bbox_count = 0
        polygon_count = 0
        
        for label_file in label_files[:10]:  # Pr√ºfe nur erste 10 Dateien
            try:
                with open(label_file, 'r', encoding='utf-8') as f:
                    content = f.read().strip()
                    if not content:
                        continue
                        
                    for line in content.split('\n'):
                        line = line.strip()
                        if not line:
                            continue
                            
                        parts = line.split()
                        if len(parts) == 5:
                            bbox_count += 1
                        elif len(parts) >= 7 and (len(parts) - 1) % 2 == 0:
                            polygon_count += 1
            except Exception:
                continue
            finally:
                if bbox_count > 0 and polygon_count > 0:
                    break  # Fr√ºh beenden wenn beide Typen gefunden
                elif polygon_count > 0:
                    break  # Fr√ºh beenden wenn Polygon gefunden
    
    def get_default_model_path(self, model_type: str = None) -> str:
        """Gibt Standard-Modell-Pfad basierend auf Annotation-Typ zur√ºck."""
        if model_type is None:
            model_type = self.get_recommended_model_type()

        if model_type == "segmentation":
            return "yolo11n-seg.pt"
        else:
            return "yolo11n.pt"

    def get_augmented_dir(self) -> Path:
        """Verzeichnis f√ºr augmentierte Daten"""
        path = self.project_root / "03_augmented"
        path.mkdir(exist_ok=True)
        return path
    
    def get_split_dir(self) -> Path:
        """Verzeichnis f√ºr Train/Val/Test Split"""
        path = self.project_root / "04_splitted"
        path.mkdir(exist_ok=True)
        return path
    
    def get_models_dir(self) -> Path:
        """Verzeichnis f√ºr trainierte Modelle"""
        path = self.project_root / "05_models"
        path.mkdir(exist_ok=True)
        return path
    
    def get_verification_dir(self) -> Path:
        """Verzeichnis f√ºr Verifikations-Resultate"""
        path = self.project_root / "06_verification"
        path.mkdir(exist_ok=True)
        return path
    
    def get_logs_dir(self) -> Path:
        """Verzeichnis f√ºr Logs"""
        path = self.project_root / "07_logs"
        path.mkdir(exist_ok=True)
        return path
    
    def get_yaml_file(self) -> Path:
        """YAML-Datei f√ºr YOLO-Training"""
        return self.get_split_dir() / "data.yaml"
    
    def get_current_model_path(self) -> Optional[Path]:
        """Pfad zum aktuell aktiven Modell"""
        if not self.config.current_model:
            return None
        path = self.get_models_dir() / f"best_{self.config.current_model}.pt"
        return path if path.exists() else None
    
    def get_latest_model_path(self) -> Optional[Path]:
        """Pfad zum neuesten Modell (falls kein current_model gesetzt)"""
        if not self.config.models:
            return None
        latest = max(self.config.models, key=lambda x: x['timestamp'])
        path = self.get_models_dir() / f"best_{latest['timestamp']}.pt"
        return path if path.exists() else None
    
    # ==================== KLASSEN-MANAGEMENT ====================
    
    def add_class(self, class_id: int, class_name: str, color: str = None) -> bool:
        """F√ºgt neue Objektklasse hinzu"""
        try:
            if color is None:
                # Automatische Farbzuweisung
                color_palette = ["#FF0000", "#00FF00", "#0000FF", "#FFFF00", 
                               "#FF00FF", "#00FFFF", "#FFA500", "#800080"]
                color = color_palette[class_id % len(color_palette)]
            
            self.config.classes[class_id] = class_name
            self.config.class_colors[class_id] = color
            self.save_config()
            self._update_yaml_file()
            
            logger.info(f"Klasse hinzugef√ºgt: {class_id} = {class_name} ({color})")
            return True
            
        except Exception as e:
            logger.error(f"Fehler beim Hinzuf√ºgen der Klasse: {e}")
            return False
    
    def remove_class(self, class_id: int) -> bool:
        """Entfernt Objektklasse"""
        try:
            if class_id in self.config.classes:
                class_name = self.config.classes[class_id]
                del self.config.classes[class_id]
                del self.config.class_colors[class_id]
                self.save_config()
                self._update_yaml_file()
                
                logger.info(f"Klasse entfernt: {class_id} = {class_name}")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Fehler beim Entfernen der Klasse: {e}")
            return False
    
    def get_classes(self) -> Dict[int, str]:
        """Gibt alle Klassen zur√ºck"""
        return self.config.classes.copy()
    
    def get_class_colors(self) -> Dict[int, str]:
        """Gibt alle Klassenfarben zur√ºck"""
        return self.config.class_colors.copy()
    
    def _update_yaml_file(self):
        """Aktualisiert YAML-Datei f√ºr YOLO-Training"""
        try:
            yaml_data = {
                'path': str(self.get_split_dir()),
                'train': 'train/images',
                'val': 'val/images', 
                'test': 'test/images',
                'nc': len(self.config.classes),
                'names': self.config.classes
            }
            
            yaml_file = self.get_yaml_file()
            yaml_file.parent.mkdir(parents=True, exist_ok=True)  # Stelle sicher dass Verzeichnis existiert
            
            with open(yaml_file, 'w', encoding='utf-8') as f:
                yaml.dump(yaml_data, f, default_flow_style=False, allow_unicode=True)
            
            logger.debug(f"YAML-Datei aktualisiert: {yaml_file}")
            
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der YAML-Datei: {e}")
            raise
    
    # ==================== MODEL-VERSIONIERUNG ====================
    
    def register_new_model(self, source_model_path: str, accuracy: float = None, 
                          training_params: Dict = None) -> str:
        """Registriert neues trainiertes Modell mit Timestamp"""
        try:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Pr√ºfe ob Quell-Modell existiert
            source_path = Path(source_model_path)
            if not source_path.exists():
                raise FileNotFoundError(f"Quell-Modell nicht gefunden: {source_model_path}")
            
            # Modell in Projektverzeichnis kopieren
            target_path = self.get_models_dir() / f"best_{timestamp}.pt"
            shutil.copy2(source_path, target_path)
            
            # Modell-Info speichern
            model_info = {
                'timestamp': timestamp,
                'accuracy': accuracy,
                'training_params': training_params or {},
                'path': str(target_path),
                'created_date': datetime.now().isoformat(),
                'source_path': str(source_path)
            }
            
            self.config.models.append(model_info)
            self.config.current_model = timestamp  # Neues Modell wird automatisch aktiv
            
            # Automatisch Live Detection Settings aktualisieren
            self.config.live_detection_settings['model_path'] = str(target_path)
            
            self.save_config()
            
            logger.info(f"Neues Modell registriert: {timestamp} (Accuracy: {accuracy})")
            return timestamp
            
        except Exception as e:
            logger.error(f"Fehler beim Registrieren des Modells: {e}")
            raise
    
    def set_active_model(self, timestamp: str) -> bool:
        """Setzt aktives Modell"""
        try:
            model_info = next((m for m in self.config.models if m['timestamp'] == timestamp), None)
            if model_info:
                self.config.current_model = timestamp
                # Live Detection Settings aktualisieren
                self.config.live_detection_settings['model_path'] = model_info['path']
                self.save_config()
                logger.info(f"Aktives Modell gesetzt: {timestamp}")
                return True
            
            logger.warning(f"Modell nicht gefunden: {timestamp}")
            return False
            
        except Exception as e:
            logger.error(f"Fehler beim Setzen des aktiven Modells: {e}")
            return False
    
    def get_model_list(self) -> List[Dict]:
        """Gibt Liste aller Modelle zur√ºck"""
        return self.config.models.copy()
    
    def delete_model(self, timestamp: str) -> bool:
        """L√∂scht Modell (Datei + Registrierung)"""
        try:
            model_info = next((m for m in self.config.models if m['timestamp'] == timestamp), None)
            if not model_info:
                logger.warning(f"Modell zum L√∂schen nicht gefunden: {timestamp}")
                return False
            
            # Datei l√∂schen
            model_path = Path(model_info['path'])
            if model_path.exists():
                model_path.unlink()
                logger.info(f"Modell-Datei gel√∂scht: {model_path}")
            
            # Aus Config entfernen
            self.config.models = [m for m in self.config.models if m['timestamp'] != timestamp]
            
            # Falls es das aktive Modell war, neues aktives setzen
            if self.config.current_model == timestamp:
                if self.config.models:
                    latest = max(self.config.models, key=lambda x: x['timestamp'])
                    self.config.current_model = latest['timestamp']
                    self.config.live_detection_settings['model_path'] = latest['path']
                    logger.info(f"Neues aktives Modell: {latest['timestamp']}")
                else:
                    self.config.current_model = None
                    self.config.live_detection_settings['model_path'] = ''
                    logger.info("Kein aktives Modell mehr vorhanden")
            
            self.save_config()
            logger.info(f"Modell erfolgreich gel√∂scht: {timestamp}")
            return True
            
        except Exception as e:
            logger.error(f"Fehler beim L√∂schen des Modells: {e}")
            return False
    
    # ==================== WORKFLOW-MANAGEMENT ====================
    
    def mark_step_completed(self, step: WorkflowStep):
        """Markiert Workflow-Schritt als abgeschlossen"""
        try:
            self.config.workflow_status[step.value] = True
            self.save_config()
            logger.info(f"Workflow-Schritt abgeschlossen: {step.value}")
        except Exception as e:
            logger.error(f"Fehler beim Markieren des Workflow-Schritts: {e}")
    
    def is_step_completed(self, step: WorkflowStep) -> bool:
        """Pr√ºft ob Workflow-Schritt abgeschlossen ist"""
        return self.config.workflow_status.get(step.value, False)
    
    def get_workflow_status(self) -> Dict[str, bool]:
        """Gibt kompletten Workflow-Status zur√ºck"""
        return self.config.workflow_status.copy()
    
    def validate_workflow_step(self, step: WorkflowStep) -> Tuple[bool, str]:
        """Validiert ob Schritt ausgef√ºhrt werden kann"""
        try:
            validations = {
                WorkflowStep.CAMERA: lambda: (True, "Bereit f√ºr Bilderfassung"),
                WorkflowStep.LABELING: lambda: self._validate_raw_images(),
                WorkflowStep.AUGMENTATION: lambda: self._validate_labeled_data(),
                WorkflowStep.SPLITTING: lambda: self._validate_augmented_data(),
                WorkflowStep.TRAINING: lambda: self._validate_split_data(),
                WorkflowStep.VERIFICATION: lambda: self._validate_trained_model(),
                WorkflowStep.LIVE_DETECTION: lambda: self._validate_trained_model()
            }
            
            return validations[step]()
            
        except Exception as e:
            logger.error(f"Fehler bei Workflow-Validierung: {e}")
            return False, f"Validierungsfehler: {str(e)}"
    
    def _validate_raw_images(self) -> Tuple[bool, str]:
        """Validiert ob rohe Bilder vorhanden sind"""
        try:
            raw_dir = self.get_raw_images_dir()
            image_files = list(raw_dir.glob("*.jpg")) + list(raw_dir.glob("*.png"))
            if not image_files:
                return False, "Keine Bilder im Raw-Images Verzeichnis gefunden. Bitte zuerst Bilder aufnehmen."
            return True, f"{len(image_files)} Bilder gefunden."
            logger.warning(f"Error detecting annotation type: {e}")
            return False, f"Fehler beim Pr√ºfen der rohen Bilder: {str(e)}"
    
    def _validate_labeled_data(self) -> Tuple[bool, str]:
        """Detect annotation type from existing labels (legacy method)."""
        try:
            labeled_dir = self.get_labeled_dir()
            image_files = list(labeled_dir.glob("*.jpg")) + list(labeled_dir.glob("*.png"))
            label_files = list(labeled_dir.glob("*.txt"))
            
            if not image_files:
                return False, "Keine gelabelten Bilder gefunden. Bitte zuerst Bilder labeln."
            if not label_files:
                return False, "Keine Label-Dateien gefunden. Bitte zuerst Annotations erstellen."
            if not self.config.classes:
                return False, "Keine Objektklassen definiert. Bitte zuerst Klassen erstellen."
            
            return True, f"{len(image_files)} gelabelte Bilder gefunden."
        except Exception as e:
            return False, f"Fehler beim Pr√ºfen der gelabelten Daten: {str(e)}"
    
    def _validate_augmented_data(self) -> Tuple[bool, str]:
        """Validiert ob augmentierte Daten vorhanden sind"""
        try:
            # Falls Augmentation √ºbersprungen wird, pr√ºfe labeled data
            aug_dir = self.get_augmented_dir()
            aug_files = list(aug_dir.glob("*.jpg")) + list(aug_dir.glob("*.png"))
            
            if aug_files:
                return True, f"{len(aug_files)} augmentierte Bilder gefunden."
            else:
                # Erlaube auch direkte Nutzung von labeled data
                return self._validate_labeled_data()
        except Exception as e:
            return False, f"Fehler beim Pr√ºfen der augmentierten Daten: {str(e)}"
    
    def _validate_split_data(self) -> Tuple[bool, str]:
        """Validiert ob Split-Daten und YAML vorhanden sind"""
        try:
            yaml_file = self.get_yaml_file()
            if not yaml_file.exists():
                return False, "YAML-Datei nicht gefunden. Bitte zuerst Dataset splitten."
            
            split_dir = self.get_split_dir()
            train_images = list((split_dir / "train" / "images").glob("*.jpg"))
            val_images = list((split_dir / "val" / "images").glob("*.jpg"))
            
            if not train_images:
                return False, "Keine Trainingsbilder gefunden. Bitte Dataset splitten."
            if not val_images:
                return False, "Keine Validierungsbilder gefunden. Bitte Dataset splitten."
            
            return True, f"Split-Dataset: {len(train_images)} Train, {len(val_images)} Val Bilder."
        except Exception as e:
            return False, f"Fehler beim Pr√ºfen der Split-Daten: {str(e)}"
    
    def _validate_trained_model(self) -> Tuple[bool, str]:
        """Validiert ob trainiertes Modell vorhanden ist"""
        try:
            if not self.config.models:
                return False, "Kein trainiertes Modell gefunden. Bitte zuerst Training durchf√ºhren."

            current_model_path = self.get_current_model_path()
            if not current_model_path or not current_model_path.exists():
                return False, "Aktives Modell nicht gefunden. Bitte Modell-Pfad √ºberpr√ºfen."

            return True, f"Aktives Modell: {self.config.current_model}"
        except Exception as e:
            return False, f"Fehler beim Pr√ºfen des trainierten Modells: {str(e)}"
    
    # ==================== SETTINGS-MANAGEMENT - ENHANCED ====================
    
    def update_camera_settings(self, settings: Dict):
        """Aktualisiert Kamera-Einstellungen"""
        try:
            self.config.camera_settings.update(settings)
            self.save_config()
            logger.debug("Kamera-Einstellungen aktualisiert")
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der Kamera-Einstellungen: {e}")
    
    def update_augmentation_settings(self, settings: Dict):
        """Aktualisiert Augmentation-Einstellungen"""
        try:
            self.config.augmentation_settings.update(settings)
            self.save_config()
            logger.debug("Augmentation-Einstellungen aktualisiert")
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der Augmentation-Einstellungen: {e}")
    
    def update_training_settings(self, settings: Dict):
        """Aktualisiert Training-Einstellungen"""
        try:
            self.config.training_settings.update(settings)
            self.save_config()
            logger.debug("Training-Einstellungen aktualisiert")
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der Training-Einstellungen: {e}")
    
    def update_live_detection_settings(self, settings: Dict):
        """Aktualisiert Live Detection Einstellungen - ENHANCED"""
        try:
            self.config.live_detection_settings.update(settings)
            self.save_config()
            logger.debug("Live Detection Einstellungen aktualisiert")
        except Exception as e:
            logger.error(f"Fehler beim Aktualisieren der Live Detection Einstellungen: {e}")
    
    def get_camera_settings(self) -> Dict:
        """Gibt Kamera-Einstellungen zur√ºck"""
        return self.config.camera_settings.copy()
    
    def get_augmentation_settings(self) -> Dict:
        """Gibt Augmentation-Einstellungen zur√ºck"""
        return self.config.augmentation_settings.copy()
    
    def get_training_settings(self) -> Dict:
        """Gibt Training-Einstellungen zur√ºck"""
        return self.config.training_settings.copy()
    
    def get_live_detection_settings(self) -> Dict:
        """Gibt Live Detection Einstellungen zur√ºck - ENHANCED"""
        return self.config.live_detection_settings.copy()

    # ==================== TRAINING EXPERIMENT UTILS ====================

    def _collect_experiment_indices(self) -> List[int]:
        """Liest existierende Trainingsordner und gibt deren Index zur√ºck."""
        pattern = f"Training_{self.config.project_name}_"
        indices = []
        try:
            for entry in self.project_root.iterdir():
                if entry.is_dir() and entry.name.startswith(pattern):
                    try:
                        idx = int(entry.name.replace(pattern, ""))
                        indices.append(idx)
                    except ValueError:
                        continue
        except Exception as e:
            logger.warning(f"Fehler beim Sammeln der Trainingsordner: {e}")
        return indices

    def get_last_experiment_name(self) -> Optional[str]:
        """Gibt den Namen des letzten Trainings-Experiments zur√ºck."""
        indices = self._collect_experiment_indices()
        if not indices:
            return None
        last_idx = max(indices)
        return f"Training_{self.config.project_name}_{last_idx:02d}"

    def get_next_experiment_name(self) -> str:
        """Erzeugt den Namen f√ºr das n√§chste Training-Experiment."""
        indices = self._collect_experiment_indices()
        next_idx = (max(indices) + 1) if indices else 1
        return f"Training_{self.config.project_name}_{next_idx:02d}"
        
    # ==================== SPECIFIC LIVE DETECTION METHODS ====================
    
    def set_model_path(self, model_path: str):
        """Setzt Modell-Pfad f√ºr Live Detection"""
        self.config.live_detection_settings['model_path'] = model_path
        self.save_config()
    
    def set_yaml_path(self, yaml_path: str):
        """Setzt YAML-Pfad f√ºr Live Detection"""
        self.config.live_detection_settings['yaml_path'] = yaml_path
        self.save_config()
    
    def set_motion_detection_enabled(self, enabled: bool):
        """Aktiviert/Deaktiviert Motion Detection"""
        self.config.live_detection_settings['motion_detection_enabled'] = enabled
        self.save_config()
        logger.info(f"Motion Detection {'aktiviert' if enabled else 'deaktiviert'}")
    
    def set_detection_enabled(self, enabled: bool):
        """Aktiviert/Deaktiviert Objekterkennung"""
        self.config.live_detection_settings['detection_enabled'] = enabled
        self.save_config()
        logger.info(f"Objekterkennung {'aktiviert' if enabled else 'deaktiviert'}")
    
    def set_class_threshold(self, class_id: int, threshold: float):
        """Setzt Threshold f√ºr spezifische Klasse"""
        self.config.live_detection_settings['class_thresholds'][str(class_id)] = threshold
        self.save_config()
    
    def set_camera_connection(self, ip: str, user: str, password: str):
        """Setzt Kamera-Verbindungsparameter"""
        self.config.live_detection_settings['connection'].update({
            'ip': ip,
            'user': user,
            'password': password
        })
        self.save_config()
    
    def set_streaming_parameters(self, fps: int, quality: int, stream_type: str):
        """Setzt Streaming-Parameter"""
        self.config.live_detection_settings.update({
            'fps': fps,
            'quality': quality,
            'stream_type': stream_type
        })
        self.save_config()
    
    # ==================== CONTINUAL LEARNING ====================
    
    def prepare_continual_training(self) -> Tuple[bool, str, Dict]:
        """Bereitet Continual Learning vor (neue Bilder zu bestehendem Modell)"""
        try:
            # Pr√ºfe ob neues Material vorhanden ist
            raw_dir = self.get_raw_images_dir()
            labeled_dir = self.get_labeled_dir() 
            
            # Neue Bilder seit letztem Training finden
            if not self.config.models:
                return False, "Kein Basis-Modell f√ºr Continual Learning gefunden.", {}
            
            last_training = max(self.config.models, key=lambda x: x['timestamp'])
            last_training_time = datetime.fromisoformat(last_training['created_date'])
            
            # Neue Bilder finden
            new_images = []
            for img_file in labeled_dir.glob("*.jpg"):
                if datetime.fromtimestamp(img_file.stat().st_mtime) > last_training_time:
                    new_images.append(img_file)
            
            if not new_images:
                    return False, "Keine neuen Bilder seit letztem Training gefunden.", {}
            
            # Training-Parameter f√ºr Continual Learning
            training_params = {
                'resume': str(self.get_current_model_path()),  # Wichtig f√ºr Ultralytics!
                'data': str(self.get_yaml_file()),
                'epochs': 50,  # Weniger Epochen f√ºr Fine-tuning
                'lr0': 0.001,  # Niedrigere Learning Rate
                'project': str(self.get_models_dir()),
                'name': f'continual_{datetime.now().strftime("%Y%m%d_%H%M%S")}'
            }
            
            return True, f"{len(new_images)} neue Bilder f√ºr Continual Learning gefunden.", training_params
            
        except Exception as e:
            logger.error(f"Fehler bei Continual Learning Vorbereitung: {e}")
            return False, f"Fehler: {str(e)}", {}


if __name__ == "__main__":
    # Test-Code f√ºr direktes Ausf√ºhren
    print("üß™ Teste Enhanced Projekt-Manager...")
    
    try:
        from PyQt6.QtWidgets import QApplication
        import sys
        
        app = QApplication(sys.argv)
        
        # Test Enhanced Projekt-Manager Dialog
        dialog = ProjectManagerDialog()
        dialog.show()
        
        sys.exit(app.exec())
        
    except Exception as e:
        print(f"‚ùå Test fehlgeschlagen: {e}")
        import traceback
        traceback.print_exc()